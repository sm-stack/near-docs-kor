"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8015],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),f=r,m=p["".concat(l,".").concat(f)]||p[f]||d[f]||o;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},50153:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>f,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=n(87462),r=n(63366),o=(n(67294),n(3905)),i=["components"],s={sidebar_position:2},l="Contract Mutability",c={unversionedId:"sdk/rust/contract-interface/contract-mutability",id:"sdk/rust/contract-interface/contract-mutability",title:"Contract Mutability",description:"Contract state mutability is handled automatically based on how self is used in the function parameters. Depending on which is used, the #[near_bindgen] macro will generate the respective code to load/deserialize state for any function which uses self and serialize/store state only for when &mut self is used.",source:"@site/../docs/sdk/rust/contract-interface/contract-mutability.md",sourceDirName:"sdk/rust/contract-interface",slug:"/sdk/rust/contract-interface/contract-mutability",permalink:"/near-docs-kor/zh-CN/sdk/rust/contract-interface/contract-mutability",draft:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/sdk/rust/contract-interface/contract-mutability.md",tags:[],version:"current",lastUpdatedBy:"[sm-stack]",lastUpdatedAt:1675844989,formattedLastUpdatedAt:"2023\u5e742\u67088\u65e5",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"sdk",previous:{title:"Public Method Types",permalink:"/near-docs-kor/zh-CN/sdk/rust/contract-interface/public-methods"},next:{title:"Private Methods",permalink:"/near-docs-kor/zh-CN/sdk/rust/contract-interface/private-methods"}},u={},d=[{value:"Read-Only Functions",id:"read-only-functions",level:2},{value:"self (owned value)",id:"self-owned-value",level:3},{value:"&amp;self (immutable reference)",id:"self-immutable-reference",level:3},{value:"Returning derived data",id:"returning-derived-data",level:3},{value:"Mutable Functions",id:"mutable-functions",level:2},{value:"Pure Functions",id:"pure-functions",level:2}],p={toc:d};function f(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"contract-mutability"},"Contract Mutability"),(0,o.kt)("p",null,"Contract state mutability is handled automatically based on how ",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/keyword.self.html"},(0,o.kt)("inlineCode",{parentName:"a"},"self"))," is used in the function parameters. Depending on which is used, the ",(0,o.kt)("a",{parentName:"p",href:"/near-docs-kor/zh-CN/sdk/rust/contract-structure/near-bindgen"},(0,o.kt)("inlineCode",{parentName:"a"},"#[near_bindgen]"))," macro will generate the respective code to load/deserialize state for any function which uses ",(0,o.kt)("inlineCode",{parentName:"p"},"self")," and serialize/store state only for when ",(0,o.kt)("inlineCode",{parentName:"p"},"&mut self")," is used."),(0,o.kt)("p",null,"The following semantics are consistent for all ",(0,o.kt)("a",{parentName:"p",href:"/near-docs-kor/zh-CN/sdk/rust/contract-interface/public-methods"},"public methods"),"."),(0,o.kt)("h2",{id:"read-only-functions"},"Read-Only Functions"),(0,o.kt)("p",null,"To access state immutably, where the existing state is not overwritten at the end of the transaction, you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"&self")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"self")," as a parameter. Both of these will generate the same code to load and deserialize the state into the structure and call the function, but the difference is that ",(0,o.kt)("inlineCode",{parentName:"p"},"&self")," will just pass a reference to this variable into the function where ",(0,o.kt)("inlineCode",{parentName:"p"},"self")," will move the variable into the function."),(0,o.kt)("p",null,"For more information about ",(0,o.kt)("inlineCode",{parentName:"p"},"&self")," versus ",(0,o.kt)("inlineCode",{parentName:"p"},"self")," see ",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html?highlight=capture%20self#defining-methods"},"this section in the Rust book"),"."),(0,o.kt)("p",null,"Here are some examples of using each:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct MyContractStructure {\n    integer: u64,\n    message: String,\n}\n#[near_bindgen]\nimpl MyContractStructure {\n    pub fn get_values(self) -> (u64, String) {\n        (self.integer, self.message)\n    }\n    pub fn log_state_string(&self) {\n        near_sdk::env::log(self.message.as_bytes());\n    }\n}\n")),(0,o.kt)("p",null,"There is no simple guideline that works for every case, but here are some core reasons on when to use each:"),(0,o.kt)("h3",{id:"self-owned-value"},"self (owned value)"),(0,o.kt)("p",null,"Moving the owned value into the function can be useful if ",(0,o.kt)("inlineCode",{parentName:"p"},"self")," itself or its fields are moved within the function, as it will remove the need to ",(0,o.kt)("inlineCode",{parentName:"p"},"Clone"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"Copy")," the data."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// View method. More efficient, but can't be reused internally, because it consumes self.\npub fn get_owner_id(self) -> AccountId {\n    self.owner_id\n}\n")),(0,o.kt)("h3",{id:"self-immutable-reference"},"&self (immutable reference)"),(0,o.kt)("p",null,"This should be used when the contract state is only read or the function is re-used by other methods which do not have ",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"},"ownership")," of the variable. This can also be useful if the struct uses a lot of memory, to avoid moving a large amount of data into the function scope rather than just referencing it."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// View method. Requires cloning the account id.\npub fn get_owner_id(&self) -> AccountId {\n    self.owner_id.clone()\n}\n")),(0,o.kt)("h3",{id:"returning-derived-data"},"Returning derived data"),(0,o.kt)("p",null,"Some less common cases may intend to use read-only methods to return objects that are derived from modified objects stored in state. Below is a demonstration of this concept:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'/// View method that "modifies" state, for code structure or computational\n/// efficiency reasons. Changes state in-memory, but does NOT save the new\n/// state. If called internally by a change method, WILL result in updated\n/// contract state.\npub fn update_stats(&self, account_id: AccountId, score: U64) -> Account {\n    let account = self.accounts.get(&account_id).unwrap_or_else(|| env::panic_str("ERR_ACCT_NOT_FOUND"));\n    account.total += score;\n    account\n}\n')),(0,o.kt)("h2",{id:"mutable-functions"},"Mutable Functions"),(0,o.kt)("p",null,"Mutable functions allow for loading the existing state, modifying it, then rewriting the modified state at the end of the function call. This should be used for any transaction which modifies the contract state. Note that the serialized contract data is stored in persistent storage under the key ",(0,o.kt)("inlineCode",{parentName:"p"},"STATE"),"."),(0,o.kt)("p",null,"An example of a mutable function is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct MyContractStructure {\n    integer: u64,\n}\n#[near_bindgen]\nimpl MyContractStructure {\n    pub fn modify_value(&mut self, new_value: u64) {\n        self.integer = new_value;\n    }\n    pub fn increment_value(&mut self) {\n        self.integer += 1;\n    }\n}\n")),(0,o.kt)("h2",{id:"pure-functions"},"Pure Functions"),(0,o.kt)("p",null,"These functions do not use ",(0,o.kt)("inlineCode",{parentName:"p"},"self")," at all, and will not read or write the contract state from storage. Using public pure functions will be very rare but can be useful if returning data embedded in the contract code or executing some static shared logic that doesn't depend on state."),(0,o.kt)("p",null,"Some examples of pure functions are as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'const SOME_VALUE: u64 = 8;\n\n#[near_bindgen]\nimpl MyContractStructure {\n    pub fn log_message(/* Parameters here */) {\n        near_sdk::log!("inside log message");\n    }\n    pub fn log_u64(value: u64) {\n        near_sdk::log!("{}", value);\n    }\n    pub fn return_static_u64() -> u64 {\n        SOME_VALUE\n    }\n}\n')))}f.isMDXComponent=!0}}]);