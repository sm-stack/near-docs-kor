"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[967],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=r,m=u["".concat(s,".").concat(h)]||u[h]||d[h]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},74594:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var a=n(87462),r=n(63366),o=(n(67294),n(3905)),i=["components"],l={id:"random",title:"Random Numbers"},s=void 0,c={unversionedId:"develop/contracts/security/random",id:"develop/contracts/security/random",title:"Random Numbers",description:"When writing smart contracts in NEAR you have access to a random seed that enables you to create random numbers/strings",source:"@site/../docs/2.develop/contracts/security/random.md",sourceDirName:"2.develop/contracts/security",slug:"/develop/contracts/security/random",permalink:"/near-docs-kor/zh-CN/develop/contracts/security/random",draft:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/2.develop/contracts/security/random.md",tags:[],version:"current",lastUpdatedBy:"[sm-stack]",lastUpdatedAt:1675844989,formattedLastUpdatedAt:"2023\u5e742\u67088\u65e5",frontMatter:{id:"random",title:"Random Numbers"},sidebar:"develop",previous:{title:"Reentrancy Attacks",permalink:"/near-docs-kor/zh-CN/develop/contracts/security/reentrancy"},next:{title:"Audit Program",permalink:"/near-docs-kor/zh-CN/develop/contracts/security/audits"}},p={},d=[{value:"Gaming the Input",id:"gaming-the-input",level:2},{value:"Refusing to Mine the Block",id:"refusing-to-mine-the-block",level:2}],u={toc:d};function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"When writing smart contracts in NEAR you have access to a ",(0,o.kt)("inlineCode",{parentName:"p"},"random seed")," that enables you to create random numbers/strings\nwithin your contract."),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"random seed")," is ",(0,o.kt)("strong",{parentName:"p"},"deterministic and verifiable"),": it comes from the validator that produced the block signing the previous\nblock-hash with their private key."),(0,o.kt)("p",null,"The way the random seed is created implies two things:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Only the validator mining the transaction ",(0,o.kt)("strong",{parentName:"p"},"can predict")," which random number will come out. ",(0,o.kt)("strong",{parentName:"p"},"No one else")," could predict it because nobody knows the validator's private key (except the validator itself).")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The validator ",(0,o.kt)("strong",{parentName:"p"},"cannot interfere")," with the random number being created. This is because they need to sign the previous block, over which (with a high probability) they had no control."))),(0,o.kt)("p",null,"However, notice that this still leaves room for three types of attacks from the validator:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"/near-docs-kor/zh-CN/develop/contracts/security/frontrunning"},"Frontrunning"),", which we cover in another page"),(0,o.kt)("li",{parentName:"ol"},"Gaming the input"),(0,o.kt)("li",{parentName:"ol"},"Refusing to mine the block. ")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"gaming-the-input"},"Gaming the Input"),(0,o.kt)("p",null,"Imagine you have a method that takes an input and gives a reward based on it. For example, you ask the user to choose a number,\nand if it the same as your ",(0,o.kt)("inlineCode",{parentName:"p"},"random seed")," you give them money."),(0,o.kt)("p",null,"Since the validator knows which ",(0,o.kt)("inlineCode",{parentName:"p"},"random seed")," will come out, it can create a transaction with that specific input and win the prize."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"refusing-to-mine-the-block"},"Refusing to Mine the Block"),(0,o.kt)("p",null,'One way to fix the "gaming the input" problem is to force the user to send the input first, and then decide the result on a different block.\nLet\'s call these two stages: "bet" and "resolve".'),(0,o.kt)("p",null,"In this way, a validator cannot game the input, since the ",(0,o.kt)("inlineCode",{parentName:"p"},"random")," number against which it will be compared is computed in a different block."),(0,o.kt)("p",null,"However, something that the validator can still do to increase their chance of winning is:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},'Create a "bet" transaction with an account.'),(0,o.kt)("li",{parentName:"ol"},'When it\'s their turn to validate, decide if they want to "resolve" or not.')),(0,o.kt)("p",null,"If the validator, on their turn, sees that generating a random number makes them win, they can add the transaction to the block. And if they\nsee that they will not, they can skip the transaction."),(0,o.kt)("p",null,"While this does not ensure that the validator will win (other good validators could mine the transaction), it can improve their chance of winning."),(0,o.kt)("p",null,"Imagine a flip-coin game, where you choose ",(0,o.kt)("inlineCode",{parentName:"p"},"heads")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"tails"),' in the "bet" stage, and later resolve if you won or not. If you are a validator\nyou can send a first transaction choosing either input.'),(0,o.kt)("p",null,"Then, on your turn to validate, you can check if your chosen input came out. If not, you can simply skip the transaction. This brings your\nprobability of winning from ",(0,o.kt)("inlineCode",{parentName:"p"},"1/2")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"3/4"),", that's a 25% increase!"),(0,o.kt)("p",null,"These odds, of course, dilute in games with more possible outcomes."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"How does the math work here?"),(0,o.kt)("p",null,"Imagine you always bet for ",(0,o.kt)("inlineCode",{parentName:"p"},"heads"),"."),(0,o.kt)("p",null,"In a fair coin-flip game you have 50-50 percent chance of winning, this is because after the coin is flipped there are two possible outcomes:\n",(0,o.kt)("inlineCode",{parentName:"p"},"H")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"T"),", and you only win in one (",(0,o.kt)("inlineCode",{parentName:"p"},"H"),")."),(0,o.kt)("p",null,"However, if you can choose to flip again if ",(0,o.kt)("inlineCode",{parentName:"p"},"tails")," comes out, now there are 4 scenarios: ",(0,o.kt)("inlineCode",{parentName:"p"},"H H")," ",(0,o.kt)("inlineCode",{parentName:"p"},"T H")," ",(0,o.kt)("inlineCode",{parentName:"p"},"H T")," ",(0,o.kt)("inlineCode",{parentName:"p"},"T T"),", and in 3 of those\nyou win (all the ones including an ",(0,o.kt)("inlineCode",{parentName:"p"},"H"),")!!!.")))}h.isMDXComponent=!0}}]);