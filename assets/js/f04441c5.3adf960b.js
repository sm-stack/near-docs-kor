"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8315],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=o,f=u["".concat(l,".").concat(d)]||u[d]||h[d]||r;return n?a.createElement(f,i(i({ref:t},c),{},{components:n})):a.createElement(f,i({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},60183:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>p,toc:()=>h});var a=n(87462),o=n(63366),r=(n(67294),n(3905)),i=["components"],s={id:"approvals",title:"Approvals",sidebar_label:"Approvals"},l=void 0,p={unversionedId:"tutorials/nfts/js/approvals",id:"tutorials/nfts/js/approvals",title:"Approvals",description:"In this tutorial you'll learn the basics of an approval management system which will allow you to grant others access to transfer NFTs on your behalf. This is the backbone of all NFT marketplaces and allows for some complex yet beautiful scenarios to happen. If you're joining us for the first time, feel free to clone this repository and checkout the 4.core branch to follow along.",source:"@site/../docs/3.tutorials/nfts/js/5-approval.md",sourceDirName:"3.tutorials/nfts/js",slug:"/tutorials/nfts/js/approvals",permalink:"/near-docs-kor/tutorials/nfts/js/approvals",draft:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/3.tutorials/nfts/js/5-approval.md",tags:[],version:"current",lastUpdatedBy:"[sm-stack]",lastUpdatedAt:1675844989,formattedLastUpdatedAt:"Feb 8, 2023",sidebarPosition:5,frontMatter:{id:"approvals",title:"Approvals",sidebar_label:"Approvals"},sidebar:"tutorials",previous:{title:"Core",permalink:"/near-docs-kor/tutorials/nfts/js/core"},next:{title:"Royalty",permalink:"/near-docs-kor/tutorials/nfts/js/royalty"}},c={},h=[{value:"Introduction",id:"introduction",level:2},{value:"Allow an account to transfer your NFT",id:"allow-an-account-to-transfer-your-nft",level:2},{value:"The problem",id:"the-problem",level:3},{value:"The solution",id:"the-solution",level:3},{value:"Expanding the <code>Token</code> and <code>JsonToken</code> structs",id:"expanding-the-token-and-jsontoken-structs",level:3},{value:"Approving accounts",id:"approving-accounts",level:3},{value:"Marketplace Integrations",id:"marketplace-integrations",level:4},{value:"Internal functions",id:"internal-functions",level:4},{value:"Changing the restrictions for transferring NFTs",id:"changing-the-restrictions-for-transferring-nfts",level:3},{value:"Refunding storage on transfer",id:"refunding-storage-on-transfer",level:4},{value:"Changes to <code>nft_core.ts</code>",id:"changes-to-nft_corets",level:3},{value:"Check if an account is approved",id:"check-if-an-account-is-approved",level:2},{value:"Revoke an account",id:"revoke-an-account",level:2},{value:"Revoke all accounts",id:"revoke-all-accounts",level:2},{value:"Testing the new changes",id:"testing-changes",level:2},{value:"Creating a sub-account",id:"creating-sub-account",level:3},{value:"Initialization and minting",id:"initialization-and-minting",level:3},{value:"Approving an account",id:"approving-an-account",level:3},{value:"Transferring an NFT as an approved account",id:"transferring-the-nft",level:3},{value:"Conclusion",id:"conclusion",level:2}],u={toc:h};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this tutorial you'll learn the basics of an approval management system which will allow you to grant others access to transfer NFTs on your behalf. This is the backbone of all NFT marketplaces and allows for some complex yet beautiful scenarios to happen. If you're joining us for the first time, feel free to clone ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/near-examples/nft-tutorial"},"this repository")," and checkout the ",(0,r.kt)("inlineCode",{parentName:"p"},"4.core")," branch to follow along."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The JS-SDK is currently in ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://github.com/near/near-sdk-js/releases/"},(0,r.kt)("inlineCode",{parentName:"a"},"Alpha"))),". ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git checkout 4.core\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"If you wish to see the finished code for this ",(0,r.kt)("em",{parentName:"p"},"Approval")," tutorial, you can find it on the ",(0,r.kt)("inlineCode",{parentName:"p"},"5.approval")," branch.")),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Up until this point you've created a smart contract that allows users to mint and transfer NFTs as well as query for information using the ",(0,r.kt)("a",{parentName:"p",href:"https://nomicon.io/Standards/NonFungibleToken/Enumeration.html"},"enumeration standard"),". As we've been doing in the previous tutorials, let's break down the problem into smaller, more digestible, tasks. Let's first define some of the end goals that we want to accomplish as per the ",(0,r.kt)("a",{parentName:"p",href:"https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html"},"approval management")," extension of the standard. We want a user to have the ability to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Grant other accounts access to transfer their NFTs on a per token basis."),(0,r.kt)("li",{parentName:"ul"},"Check if an account has access to a specific token."),(0,r.kt)("li",{parentName:"ul"},"Revoke a specific account the ability to transfer an NFT."),(0,r.kt)("li",{parentName:"ul"},"Revoke ",(0,r.kt)("strong",{parentName:"li"},"all")," other accounts the ability to transfer an NFT.")),(0,r.kt)("p",null,"If you look at all these goals, they are all on a per token basis. This is a strong indication that you should change the ",(0,r.kt)("inlineCode",{parentName:"p"},"Token")," struct which keeps track of information for each token."),(0,r.kt)("h2",{id:"allow-an-account-to-transfer-your-nft"},"Allow an account to transfer your NFT"),(0,r.kt)("p",null,"Let's start by trying to accomplish the first goal. How can you grant another account access to transfer an NFT on your behalf?"),(0,r.kt)("p",null,"The simplest way that you can achieve this is to add a list of approved accounts to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Token")," struct. When transferring the NFT, if the caller is not the owner, you could check if they're in the list."),(0,r.kt)("p",null,"Before transferring, you would need to clear the list of approved accounts since the new owner wouldn't expect the accounts approved by the original owner to still have access to transfer their new NFT."),(0,r.kt)("h3",{id:"the-problem"},"The problem"),(0,r.kt)("p",null,"On the surface, this would work, but if you start thinking about the edge cases, some problems arise. Often times when doing development, a common approach is to think about the easiest and most straightforward solution. Once you've figured it out, you can start to branch off and think about optimizations and edge cases."),(0,r.kt)("p",null,"Let's consider the following scenario. Benji has an NFT and gives two separate marketplaces access to transfer his token. By doing so, he's putting the NFT for sale (more about that in the ",(0,r.kt)("a",{parentName:"p",href:"#marketplace-integrations"},"marketplace integrations")," section). Let's say he put the NFT for sale for 1 NEAR on both markets. The token's list of approved account IDs would look like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Token: {\n    owner_id: Benji\n    approved_accounts_ids: [marketplace A, marketplace B]\n}\n")),(0,r.kt)("p",null,"Josh then comes along and purchases the NFT on marketplace A for 1 NEAR. This would take the sale down from the marketplace A and clear the list of approved accounts. Marketplace B, however, still has the token listed for sale for 1 NEAR and has no way of knowing that the token was purchased on marketplace A by Josh. The new token struct would look as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Token: {\n    owner_id: Josh\n    approved_accounts_ids: []\n}\n")),(0,r.kt)("p",null,"Let's say Josh is low on cash and wants to flip this NFT and put it for sale for 10 times the price on marketplace B. He goes to put it for sale and for whatever reason, the marketplace is built in a way that if you try to put a token up for sale twice, it keeps the old sale data. This would mean that from marketplace B's perspective, the token is still for sale for 1 NEAR (which was the price that Benji had originally listed it for)."),(0,r.kt)("p",null,"Since Josh approved the marketplace to try and put it for sale, the token struct would look as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Token: {\n    owner_id: Josh\n    approved_accounts_ids: [marketplace A, marketplace B]\n}\n")),(0,r.kt)("p",null,"If Mike then comes along and purchases the NFT for only 1 NEAR on marketplace B, the marketplace would go to try and transfer the NFT and since technically, Josh approved the marketplace and it's in the list of approved accounts, the transaction would go through properly."),(0,r.kt)("h3",{id:"the-solution"},"The solution"),(0,r.kt)("p",null,"Now that we've identified a problem with the original solution, let's think about ways that we can fix it. What would happen now if, instead of just keeping track of a list of approved accounts, you introduced a specific ID that went along with each approved account. The new approved accounts would now be a map instead of a list. It would map an account to it's ",(0,r.kt)("inlineCode",{parentName:"p"},"approval id"),"."),(0,r.kt)("p",null,"For this to work, you need to make sure that the approval ID is ",(0,r.kt)("strong",{parentName:"p"},"always")," a unique, new ID. If you set it as an integer that always increases by 1 whenever u approve an account, this should work. Let's consider the same scenario with the new solution."),(0,r.kt)("p",null,'Benji puts his NFT for sale for 1 NEAR on marketplace A and marketplace B by approving both marketplaces. The "next approval ID" would start off at 0 when the NFT was first minted and will increase from there. This would result in the following token struct:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Token: {\n    owner_id: Benji\n    approved_accounts_ids: {\n        marketplace A: 0\n        marketplace B: 1\n    }\n    next_approval_id: 2\n}\n")),(0,r.kt)("p",null,"When Benji approved marketplace A, it took the original value of ",(0,r.kt)("inlineCode",{parentName:"p"},"next_approval_id")," which started off at 0. The marketplace was then inserted into the map and the next approval ID was incremented. This process happened again for marketplace B and the next approval ID was again incremented where it's now 2."),(0,r.kt)("p",null,"Josh comes along and purchases the NFT on marketplace A for 1 NEAR. Notice how the next approval ID stayed at 2:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Token: {\n    owner_id: Josh\n    approved_accounts_ids: {}\n    next_approval_id: 2\n}\n")),(0,r.kt)("p",null,"Josh then flips the NFT because he's once again low on cash and approves marketplace B:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Token: {\n    owner_id: Josh\n    approved_accounts_ids: {\n        marketplace B: 2\n    }\n    next_approval_id: 3\n}\n")),(0,r.kt)("p",null,"The marketplace is inserted into the map and the next approval ID is incremented. From marketplace B's perspective it stores it's original approval ID from when Benji put the NFT up for sale which has a value of 1. If Mike were to go and purchase the NFT on marketplace B for the original 1 NEAR sale price, the NFT contract should panic. This is because the marketplace is trying to transfer the NFT with an approval ID 1 but the token struct shows that it ",(0,r.kt)("strong",{parentName:"p"},"should")," have an approval ID of 2."),(0,r.kt)("h3",{id:"expanding-the-token-and-jsontoken-structs"},"Expanding the ",(0,r.kt)("inlineCode",{parentName:"h3"},"Token")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"JsonToken")," structs"),(0,r.kt)("p",null,"Now that you understand the proposed solution to the original problem of allowing an account to transfer your NFT, it's time to implement some of the logic. The first thing you should do is modify the ",(0,r.kt)("inlineCode",{parentName:"p"},"Token")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonToken")," structs to reflect the new changes. Let's switch over to the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-contract/src/metadata.ts")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/metadata.ts#L106-L156\n")),(0,r.kt)("p",null,"You'll then need to initialize both the ",(0,r.kt)("inlineCode",{parentName:"p"},"approved_account_ids")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"next_approval_id")," to their default values when a token is minted. Switch to the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-contract/src/mint.ts")," file and when creating the ",(0,r.kt)("inlineCode",{parentName:"p"},"Token")," struct to store in the contract, let's set the next approval ID to be 0 and the approved account IDs to be an empty object:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/mint.ts#L23-L31\n")),(0,r.kt)("h3",{id:"approving-accounts"},"Approving accounts"),(0,r.kt)("p",null,"Now that you've added the support for approved account IDs and the next approval ID on the token level, it's time to add the logic for populating and changing those fields through a function called ",(0,r.kt)("inlineCode",{parentName:"p"},"nft_approve"),". This function should approve an account to have access to a specific token ID. Let's move to the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-contract/src/approval.ts")," file and edit the ",(0,r.kt)("inlineCode",{parentName:"p"},"internalNftApprove")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts#L9-L73\n")),(0,r.kt)("p",null,"The function will first assert that the user has attached ",(0,r.kt)("strong",{parentName:"p"},"at least")," one yoctoNEAR (which we'll implement soon). This is both for security and to cover storage. When someone approves an account ID, they're storing that information on the contract. As you saw in the ",(0,r.kt)("a",{parentName:"p",href:"/tutorials/nfts/js/minting"},"minting tutorial"),", you can either have the smart contract account cover the storage, or you can have the users cover that cost. The latter is more scalable and it's the approach you'll be working with throughout this tutorial."),(0,r.kt)("p",null,"After the assertion comes back with no problems, you get the token object and make sure that only the owner is calling this method. Only the owner should be able to allow other accounts to transfer their NFTs. You then get the next approval ID and insert the passed in account into the map with the next approval ID. If it's a new approval ID, storage must be paid. If it's not a new approval ID, no storage needs to be paid and only attaching 1 yoctoNEAR would be enough."),(0,r.kt)("p",null,"You then calculate how much storage is being used by adding that new account to the map and increment the tokens ",(0,r.kt)("inlineCode",{parentName:"p"},"next_approval_id")," by 1. After inserting the token object back into the ",(0,r.kt)("inlineCode",{parentName:"p"},"tokensById")," map, you refund any excess storage."),(0,r.kt)("p",null,"You'll notice that the function contains an optional ",(0,r.kt)("inlineCode",{parentName:"p"},"msg")," parameter. This message is actually the foundation of all NFT marketplaces on NEAR."),(0,r.kt)("h4",{id:"marketplace-integrations"},"Marketplace Integrations"),(0,r.kt)("p",null,"If a message was provided into the function, you're going to perform a cross contract call to the account being given access. This cross contract call will invoke the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft_on_approve")," function which will parse the message and act accordingly. Let's consider a general use case."),(0,r.kt)("p",null,"We have a marketplace that expects it's sale conditions to be passed in through the message field. Benji approves the marketplace with the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft_approve")," function and passes in a stringified JSON to the message which will outline sale conditions. These sale conditions could look something like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"sale_conditions: {\n    price: 5\n}\n")),(0,r.kt)("p",null,"By leaving the message field type as just a string, this generalizes the process and allows users to input sale conditions for many different marketplaces. It is up to the person approving to pass in an appropriate message that the marketplace can properly decode and use. This is usually done through the marketplace's frontend app which would know how to construct the ",(0,r.kt)("inlineCode",{parentName:"p"},"msg")," in a useful way."),(0,r.kt)("h4",{id:"internal-functions"},"Internal functions"),(0,r.kt)("p",null,"Now that the core logic for approving an account is finished, you need to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"assertAtLeastOneYocto")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"bytesForApprovedAccountId")," functions. Move to the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-contract/src/internal.ts")," file and copy the following function right below the ",(0,r.kt)("inlineCode",{parentName:"p"},"assertOneYocto")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts#L61-L64\n")),(0,r.kt)("p",null,"Next, you'll need to copy the logic for calculating how many bytes it costs to store an account ID. Place this function at the very top of the page:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts#L55-L59\n")),(0,r.kt)("p",null,"Now that the logic for approving accounts is finished, you need to change the restrictions for transferring."),(0,r.kt)("h3",{id:"changing-the-restrictions-for-transferring-nfts"},"Changing the restrictions for transferring NFTs"),(0,r.kt)("p",null,"Currently, an NFT can ",(0,r.kt)("strong",{parentName:"p"},"only")," be transferred by its owner. You need to change that restriction so that people that have been approved can also transfer NFTs. In addition, you'll make it so that if an approval ID is passed, you can increase the security and check if both the account trying to transfer is in the approved list ",(0,r.kt)("strong",{parentName:"p"},"and")," they correspond to the correct approval ID. This is to address the problem we ran into earlier."),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"internal.ts")," file, you need to change the logic of the ",(0,r.kt)("inlineCode",{parentName:"p"},"internalTransfer")," method as that's where the restrictions are being made. Change the internal transfer function to be the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts#L108-L163\n")),(0,r.kt)("p",null,"This will check if the sender isn't the owner and then if they're not, it will check if the sender is in the approval list. If an approval ID was passed into the function, it will check if the sender's actual approval ID stored on the contract matches the one passed in."),(0,r.kt)("h4",{id:"refunding-storage-on-transfer"},"Refunding storage on transfer"),(0,r.kt)("p",null,"While you're in the internal file, you're going to need to add methods for refunding users who have paid for storing approved accounts on the contract when an NFT is transferred. This is because you'll be clearing the ",(0,r.kt)("inlineCode",{parentName:"p"},"approved_account_ids")," object whenever NFTs are transferred and so the storage is no longer being used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts#L13-L28\n")),(0,r.kt)("p",null,"These will be useful in the next section where you'll be changing the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft_core")," functions to include the new approval logic."),(0,r.kt)("h3",{id:"changes-to-nft_corets"},"Changes to ",(0,r.kt)("inlineCode",{parentName:"h3"},"nft_core.ts")),(0,r.kt)("p",null,"Head over to the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-contract/src/nft_core.ts")," file and the first change that you'll want to make is to add an ",(0,r.kt)("inlineCode",{parentName:"p"},"approval_id")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"internalTransfer")," function. This is so that anyone trying to transfer the token that isn't the owner must pass in an approval ID to address the problem seen earlier. If they are the owner, the approval ID won't be used as we saw in the ",(0,r.kt)("inlineCode",{parentName:"p"},"internalTransfer")," function."),(0,r.kt)("p",null,"For the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft_transfer")," function, the only change that you'll need to make is to pass in the approval ID into the ",(0,r.kt)("inlineCode",{parentName:"p"},"internalTransfer")," function and then refund the previous tokens approved account IDs after the transfer is finished"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts#L38-L72\n")),(0,r.kt)("p",null,"Next, you need to do the same to ",(0,r.kt)("inlineCode",{parentName:"p"},"nft_transfer_call")," but instead of refunding immediately, you need to attach the previous token's approved account IDs to ",(0,r.kt)("inlineCode",{parentName:"p"},"nft_resolve_transfer")," instead as there's still the possibility that the transfer gets reverted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts#L74-L135\n")),(0,r.kt)("p",null,"You'll also need to add the tokens approved account IDs to the ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonToken")," being returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"nft_token"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts#L10-L36\n")),(0,r.kt)("p",null,"Finally, you need to add the logic for refunding the approved account IDs in ",(0,r.kt)("inlineCode",{parentName:"p"},"internalResolveTransfer"),". If the transfer went through, you should refund the owner for the storage being released by resetting the tokens ",(0,r.kt)("inlineCode",{parentName:"p"},"approved_account_ids")," field. If, however, you should revert the transfer, it wouldn't be enough to just not refund anybody. Since the receiver briefly owned the token, they could have added their own approved account IDs and so you should refund them if they did so."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts#L137-L208\n")),(0,r.kt)("p",null,"With that finished, it's time to move on and complete the next task."),(0,r.kt)("h2",{id:"check-if-an-account-is-approved"},"Check if an account is approved"),(0,r.kt)("p",null,"Now that the core logic is in place for approving and refunding accounts, it should be smooth sailing from this point on. You now need to implement the logic for checking if an account has been approved. This should take an account and token ID as well as an optional approval ID. If no approval ID was provided, it should simply return whether or not the account is approved."),(0,r.kt)("p",null,"If an approval ID was provided, it should return whether or not the account is approved and has the same approval ID as the one provided. Let's move to the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-contract/src/approval.ts")," file and add the necessary logic to the ",(0,r.kt)("inlineCode",{parentName:"p"},"internalNftIsApproved")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts#L75-L110\n")),(0,r.kt)("p",null,"Let's now move on and add the logic for revoking an account"),(0,r.kt)("h2",{id:"revoke-an-account"},"Revoke an account"),(0,r.kt)("p",null,"The next step in the tutorial is to allow a user to revoke a specific account from having access to their NFT. The first thing you'll want to do is assert one yocto for security purposes. You'll then need to make sure that the caller is the owner of the token. If those checks pass, you'll need to remove the passed in account from the tokens approved account IDs and refund the owner for the storage being released."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts#L112-L145\n")),(0,r.kt)("h2",{id:"revoke-all-accounts"},"Revoke all accounts"),(0,r.kt)("p",null,"The final step in the tutorial is to allow a user to revoke all accounts from having access to their NFT. This should also assert one yocto for security purposes and make sure that the caller is the owner of the token. You then refund the owner for releasing all the accounts in the map and then clear the ",(0,r.kt)("inlineCode",{parentName:"p"},"approved_account_ids"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"reference",reference:!0},"https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts#L147-L177\n")),(0,r.kt)("p",null,"With that finished, it's time to deploy and start testing the contract."),(0,r.kt)("h2",{id:"testing-changes"},"Testing the new changes"),(0,r.kt)("p",null,"Since these changes affect all the other tokens and the state won't be able to automatically be inherited by the new code, simply redeploying the contract will lead to errors. For this reason, it's best practice to create a sub-account and deploy the contract there."),(0,r.kt)("h3",{id:"creating-sub-account"},"Creating a sub-account"),(0,r.kt)("p",null,"Run the following command to create a sub-account ",(0,r.kt)("inlineCode",{parentName:"p"},"approval")," of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"near create-account approval.$NFT_CONTRACT_ID --masterAccount $NFT_CONTRACT_ID --initialBalance 25\n")),(0,r.kt)("p",null,"Next, you'll want to export an environment variable for ease of development:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"export APPROVAL_NFT_CONTRACT_ID=approval.$NFT_CONTRACT_ID\n")),(0,r.kt)("p",null,"Using the build script, build the deploy the contract as you did in the previous tutorials:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"yarn build && near deploy --wasmFile build/nft.wasm --accountId $APPROVAL_NFT_CONTRACT_ID\n")),(0,r.kt)("h3",{id:"initialization-and-minting"},"Initialization and minting"),(0,r.kt)("p",null,"Since this is a new contract, you'll need to initialize and mint a token. Use the following command to initialize the contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"near call $APPROVAL_NFT_CONTRACT_ID init '{\"owner_id\": \"'$APPROVAL_NFT_CONTRACT_ID'\"}' --accountId $APPROVAL_NFT_CONTRACT_ID\n")),(0,r.kt)("p",null,"Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID ",(0,r.kt)("inlineCode",{parentName:"p"},'"approval-token"')," and the receiver will be your new account."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'near call $APPROVAL_NFT_CONTRACT_ID nft_mint \'{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "\'$APPROVAL_NFT_CONTRACT_ID\'"}\' --accountId $APPROVAL_NFT_CONTRACT_ID --amount 0.1\n')),(0,r.kt)("p",null,"You can check to see if everything went through properly by calling one of the enumeration functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner \'{"account_id": "\'$APPROVAL_NFT_CONTRACT_ID\'", "limit": 10}\'\n')),(0,r.kt)("p",null,"This should return an output similar to the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "token_id": "approval-token",\n    "owner_id": "approval.goteam.examples.testnet",\n    "metadata": {\n      "title": "Approval Token",\n      "description": "testing out the new approval extension of the standard",\n      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",\n    },\n    "approved_account_ids": {}\n  }\n]\n')),(0,r.kt)("p",null,"Notice how the approved account IDs are now being returned from the function? This is a great sign! You're now ready to move on and approve an account to have access to your token."),(0,r.kt)("h3",{id:"approving-an-account"},"Approving an account"),(0,r.kt)("p",null,"At this point, you should have two accounts. One stored under ",(0,r.kt)("inlineCode",{parentName:"p"},"$NFT_CONTRACT_ID")," and the other under the ",(0,r.kt)("inlineCode",{parentName:"p"},"$APPROVAL_NFT_CONTRACT_ID")," environment variable. You can use both of these accounts to test things out. If you approve your old account, it should have the ability to transfer the NFT to itself."),(0,r.kt)("p",null,"Execute the following command to approve the account stored under ",(0,r.kt)("inlineCode",{parentName:"p"},"$NFT_CONTRACT_ID")," to have access to transfer your NFT with an ID ",(0,r.kt)("inlineCode",{parentName:"p"},'"approval-token"'),". You don't need to pass a message since the old account didn't implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft_on_approve")," function. In addition, you'll need to attach enough NEAR to cover the cost of storing the account on the contract. 0.1 NEAR should be more than enough and you'll be refunded any excess that is unused."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'near call $APPROVAL_NFT_CONTRACT_ID nft_approve \'{"token_id": "approval-token", "account_id": "\'$NFT_CONTRACT_ID\'"}\' --accountId $APPROVAL_NFT_CONTRACT_ID --deposit 0.1\n')),(0,r.kt)("p",null,"If you call the same enumeration method as before, you should see the new approved account ID being returned."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner \'{"account_id": "\'$APPROVAL_NFT_CONTRACT_ID\'", "limit": 10}\'\n')),(0,r.kt)("p",null,"This should return an output similar to the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "token_id": "approval-token",\n    "owner_id": "approval.goteam.examples.testnet",\n    "metadata": {\n      "title": "Approval Token",\n      "description": "testing out the new approval extension of the standard",\n      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"\n    },\n    "approved_account_ids": { "goteam.examples.testnet": 0 }\n  }\n]\n')),(0,r.kt)("h3",{id:"transferring-the-nft"},"Transferring an NFT as an approved account"),(0,r.kt)("p",null,"Now that you've approved another account to transfer the token, you can test that behavior. You should be able to use the other account to transfer the NFT to itself by which the approved account IDs should be reset. Let's test transferring the NFT with the wrong approval ID:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'near call $APPROVAL_NFT_CONTRACT_ID nft_transfer \'{"receiver_id": "\'$NFT_CONTRACT_ID\'", "token_id": "approval-token", "approval_id": 1}\' --accountId $NFT_CONTRACT_ID --depositYocto 1\n')),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Example response: "),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kind: {\n    ExecutionError: \"Smart contract panicked: panicked at 'assertion failed: `(left == right)`\\n\" +\n      '  left: `0`,\\n' +\n      \" right: `1`: The actual approval_id 0 is different from the given approval_id 1', src/internal.ts:165:17\"\n  },\n")))),(0,r.kt)("p",null,"If you pass the correct approval ID which is ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", everything should work fine."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'near call $APPROVAL_NFT_CONTRACT_ID nft_transfer \'{"receiver_id": "\'$NFT_CONTRACT_ID\'", "token_id": "approval-token", "approval_id": 0}\' --accountId $NFT_CONTRACT_ID --depositYocto 1\n')),(0,r.kt)("p",null,"If you again call the enumeration method, you should see the owner updated and the approved account IDs reset."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "token_id": "approval-token",\n    "owner_id": "goteam.examples.testnet",\n    "metadata": {\n      "title": "Approval Token",\n      "description": "testing out the new approval extension of the standard",\n      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"\n    },\n    "approved_account_ids": {}\n  }\n]\n')),(0,r.kt)("p",null,"Let's now test the approval ID incrementing across different owners. If you approve the sub-account that originally minted the token, the approval ID should be 1 now."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'near call $APPROVAL_NFT_CONTRACT_ID nft_approve \'{"token_id": "approval-token", "account_id": "\'$APPROVAL_NFT_CONTRACT_ID\'"}\' --accountId $NFT_CONTRACT_ID --deposit 0.1\n')),(0,r.kt)("p",null,"Calling the view function again show now return an approval ID of 1 for the sub-account that was approved."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner \'{"account_id": "\'$NFT_CONTRACT_ID\'", "limit": 10}\'\n')),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Example response: "),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "token_id": "approval-token",\n    "owner_id": "goteam.examples.testnet",\n    "metadata": {\n      "title": "Approval Token",\n      "description": "testing out the new approval extension of the standard",\n      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"\n    },\n    "approved_account_ids": { "approval.goteam.examples.testnet": 1 }\n  }\n]\n')))),(0,r.kt)("p",null,"With the testing finished, you've successfully implemented the approvals extension to the standard!"),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Today you went through a lot of logic to implement the ",(0,r.kt)("a",{parentName:"p",href:"https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html"},"approvals extension")," so let's break down exactly what you did."),(0,r.kt)("p",null,"First, you explored the ",(0,r.kt)("a",{parentName:"p",href:"#basic-solution"},"basic approach")," of how to solve the problem. You then went through and discovered some of the ",(0,r.kt)("a",{parentName:"p",href:"#the-problem"},"problems")," with that solution and learned how to ",(0,r.kt)("a",{parentName:"p",href:"#the-solution"},"fix it"),"."),(0,r.kt)("p",null,"After understanding what you should do to implement the approvals extension, you started to ",(0,r.kt)("a",{parentName:"p",href:"#expanding-json-and-token"},"modify")," the JsonToken and Token structs in the contract. You then implemented the logic for ",(0,r.kt)("a",{parentName:"p",href:"#approving-accounts"},"approving accounts")," and saw how ",(0,r.kt)("a",{parentName:"p",href:"#marketplace-integrations"},"marketplaces")," are integrated."),(0,r.kt)("p",null,"After implementing the logic behind approving accounts, you went and ",(0,r.kt)("a",{parentName:"p",href:"#changing-restrictions"},"changed the restrictions")," needed to transfer NFTs. The last step you did to finalize the approving logic was to go back and edit the ",(0,r.kt)("a",{parentName:"p",href:"#nft-core-changes"},"nft_core")," files to be compatible with the new changes."),(0,r.kt)("p",null,"At this point, everything was implemented in order to allow accounts to be approved and you extended the functionality of the ",(0,r.kt)("a",{parentName:"p",href:"https://nomicon.io/Standards/NonFungibleToken/Core.html"},"core standard")," to allow for approved accounts to transfer tokens."),(0,r.kt)("p",null,"You implemented a view method to ",(0,r.kt)("a",{parentName:"p",href:"#check-if-account-approved"},"check")," if an account is approved and to finish the coding portion of the tutorial, you implemented the logic necessary to ",(0,r.kt)("a",{parentName:"p",href:"#revoke-account"},"revoke an account")," as well as ",(0,r.kt)("a",{parentName:"p",href:"#revoke-all-accounts"},"revoke all accounts"),"."),(0,r.kt)("p",null,"After this, the contract code was finished and it was time to move onto testing where you created a ",(0,r.kt)("a",{parentName:"p",href:"#creating-sub-account"},"subaccount")," and tested the ",(0,r.kt)("a",{parentName:"p",href:"#approving-an-account"},"approving")," and ",(0,r.kt)("a",{parentName:"p",href:"#transferring-the-nft"},"transferring")," for your NFTs."),(0,r.kt)("p",null,"In the next tutorial, you'll learn about the royalty standards and how you can interact with NFT marketplaces."))}d.isMDXComponent=!0}}]);