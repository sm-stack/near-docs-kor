"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9921],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(n),d=r,m=h["".concat(l,".").concat(d)]||h[d]||u[d]||a;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},42898:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>p,default:()=>k,frontMatter:()=>c,metadata:()=>u,toc:()=>d});var o=n(87462),r=n(63366),a=(n(67294),n(3905));const i=n.p+"assets/images/paging-through-hashes-swing--pierced_staggg.near--pierced_stag-252ce502eb06766d1dc11a6c40a0b60c.jpg",s=n.p+"assets/images/guards-contract-permissions--connoisseur_dane.near--connoisseurdane-a696aec63e7ccccc1442b9fe3eb4c664.png";var l=["components"],c={sidebar_position:2,sidebar_label:"Store multiple puzzles",title:"Store multiple crossword puzzles using a specialized collection in NEAR called a LookupMap"},p="Using collections",u={unversionedId:"tutorials/crosswords/beginner/collections",id:"tutorials/crosswords/beginner/collections",title:"Store multiple crossword puzzles using a specialized collection in NEAR called a LookupMap",description:"",source:"@site/../docs/3.tutorials/crosswords/02-beginner/01-collections.md",sourceDirName:"3.tutorials/crosswords/02-beginner",slug:"/tutorials/crosswords/beginner/collections",permalink:"/near-docs-kor/tutorials/crosswords/beginner/collections",draft:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/3.tutorials/crosswords/02-beginner/01-collections.md",tags:[],version:"current",lastUpdatedBy:"[sm-stack]",lastUpdatedAt:1675844989,formattedLastUpdatedAt:"Feb 8, 2023",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Store multiple puzzles",title:"Store multiple crossword puzzles using a specialized collection in NEAR called a LookupMap"},sidebar:"tutorials",previous:{title:"Overview",permalink:"/near-docs-kor/tutorials/crosswords/beginner/overview"},next:{title:"Using structs and enums",permalink:"/near-docs-kor/tutorials/crosswords/beginner/structs-enums"}},h={},d=[{value:"LookupMap and UnorderedSet",id:"lookupmap-and-unorderedset",level:2},{value:"Collections have prefixes",id:"collections-have-prefixes",level:2},{value:"Permissions or permissionless?",id:"permissions-or-permissionless",level:2}],m={toc:d};function k(e){var t=e.components,n=(0,r.Z)(e,l);return(0,a.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"using-collections"},"Using collections"),(0,a.kt)("p",null,"As mentioned in the previous chapter, the ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/book"},"online Rust Book")," is a great reference for folks getting started with Rust, but there are concepts that differ when we're dealing with the blockchain. One of these differences is the use of collections."),(0,a.kt)("p",null,"The reference-level documentation of the Rust SDK explains this concept well:"),(0,a.kt)("admonition",{title:"Motivation for specialized collections",type:"note"},(0,a.kt)("blockquote",{parentName:"admonition"},(0,a.kt)("p",{parentName:"blockquote"},"Collections that offer an alternative to standard containers from ","[Rust's]"," std::collections::* by ",(0,a.kt)("strong",{parentName:"p"},"utilizing the underlying blockchain trie storage more efficiently"),".",(0,a.kt)("br",null),"\nFor example, the following smart contract does not work with state efficiently, because ",(0,a.kt)("strong",{parentName:"p"},"it will load the entire HashMap at the beginning of the contract call"),", and will save it entirely at the end, in cases when there is state modification. ",(0,a.kt)("strong",{parentName:"p"},"This is fine for small number of elements, but very inefficient for large numbers"),".")),(0,a.kt)("p",{parentName:"admonition"},"\u2014 ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/near-sdk/latest/near_sdk/collections/index.html"},"NEAR SDK reference documentation"))),(0,a.kt)("p",null,"In chapter 1, we set the crossword puzzle solution hash when we first deployed the contract and called the initialization method ",(0,a.kt)("inlineCode",{parentName:"p"},"new"),", passing it. This would only allow us to have only one puzzle, but let's allow for many."),(0,a.kt)("p",null,"At a high level, let's discuss what we'll want to add if our contract is to store multiple crossword puzzles. First, we'll have the concept of many puzzles where some of them will have different states (unfinished and finished) and we'll want to know which ones are unsolved in quick way. Another thing, which is a general rule of thumb when writing smart contracts, is to anticipate what might happen if it gets a lot of usage. What if we end up with 10,000 crossword puzzles? How might that affect how many data structures we use and which ones?"),(0,a.kt)("h2",{id:"lookupmap-and-unorderedset"},"LookupMap and UnorderedSet"),(0,a.kt)("p",null,"Let's try having two specialized NEAR collections:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"A ",(0,a.kt)("a",{parentName:"li",href:"https://docs.rs/near-sdk/latest/near_sdk/collections/struct.LookupMap.html"},"LookupMap")," which will store key-value pairs. (Solution hash \xbb Puzzle object)"),(0,a.kt)("li",{parentName:"ol"},"An ",(0,a.kt)("a",{parentName:"li",href:"https://docs.rs/near-sdk/latest/near_sdk/collections/struct.UnorderedSet.html"},"UnorderedSet")," containing a set (list with no duplicates) of the solution hashes for puzzles which have not been solved yet.")),(0,a.kt)("p",null,"As you look at the list of specialized collections in the Rust SDK, you might notice some begin with ",(0,a.kt)("inlineCode",{parentName:"p"},"Lookup")," while others have ",(0,a.kt)("inlineCode",{parentName:"p"},"Unordered"),". As is written in the reference documentation, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Lookup")," is non-iterable while the ",(0,a.kt)("inlineCode",{parentName:"p"},"Unordered")," collections are iterable. This means if you will need to loop through the list of contents of this data structure, you'll likely use an iterable data structure. If you'll only ever be adding and retrieving data by the key, and the key will always be known, it's more efficient to use a non-iterable collection."),(0,a.kt)("p",null,"So why would we have two data structures here? Again, if we end up with a large number of puzzles, we might not be able to loop through all the puzzles, looking for ones that are unsolved. Because of the limit of gas execution per transaction, we must be conscious that there can be operations which will eventually exceed this limit. I suppose we could assume  that our ",(0,a.kt)("inlineCode",{parentName:"p"},"UnorderedSet")," of unsolved puzzles wouldn't contain tens of thousands of puzzles. That's one way to avoid running into limits, but we could also learn how to utilize ",(0,a.kt)("strong",{parentName:"p"},"pagination")," through an iterable collection like an ",(0,a.kt)("inlineCode",{parentName:"p"},"UnorderedSet")," which we'll get to later."),(0,a.kt)("figure",null,(0,a.kt)("img",{src:i,alt:"Book showing pagination of hashes. Art created by pierced_staggg.near",width:"600"}),(0,a.kt)("figcaption",null,"Think of our collection as having multiple pages of puzzle hashes.",(0,a.kt)("br",null),"Art by ",(0,a.kt)("a",{href:"https://twitter.com/pierced_stag",target:"_blank"},"pierced_staggg.near"))),(0,a.kt)("br",null),(0,a.kt)("p",null,"As we remember from the previous chapter, every smart contract has a primary struct containing the ",(0,a.kt)("inlineCode",{parentName:"p"},"#[near_bindgen]")," macro. "),(0,a.kt)("admonition",{title:"Naming the primary struct",type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Note in the ",(0,a.kt)("a",{parentName:"p",href:"/near-docs-kor/tutorials/crosswords/basics/set-up-skeleton#start-writing-rust"},"previous chapter")," we named our primary struct ",(0,a.kt)("inlineCode",{parentName:"p"},"Contract"),", but in this chapter we'll call it ",(0,a.kt)("inlineCode",{parentName:"p"},"Crossword.")),(0,a.kt)("p",{parentName:"admonition"},"The name of the struct doesn't matter and there's nothing special about naming it ",(0,a.kt)("inlineCode",{parentName:"p"},"Contract"),", though you might see that convention used in several smart contracts on NEAR. We've named it something different simply to illustrate that there's no magic behind the scenes. This ",(0,a.kt)("em",{parentName:"p"},"does")," mean, however, that our ",(0,a.kt)("inlineCode",{parentName:"p"},"impl")," block will also be ",(0,a.kt)("inlineCode",{parentName:"p"},"Crossword"),".")),(0,a.kt)("p",null,"Here's how our struct will look with the iterable and non-iterable NEAR collections:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/near-examples/crossword-tutorial-chapter-2/blob/276217ad82c64c610148e998ec926942ba910a12/contract/src/lib.rs#L73-L79\n")),(0,a.kt)("p",null,"Above, we have the ",(0,a.kt)("inlineCode",{parentName:"p"},"puzzles")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"unsolved_puzzles")," fields which are collections."),(0,a.kt)("p",null,"We also have an ",(0,a.kt)("inlineCode",{parentName:"p"},"owner_id")," so we can exercise a common pattern in smart contract development: implementing a rudimentary permission system which can restrict access to certain functions. We'll expand on this thought in a moment."),(0,a.kt)("p",null,"The snippet below shows the first method in the implementation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Crossword")," struct, where the ",(0,a.kt)("inlineCode",{parentName:"p"},"new")," function sets up these two specialized collections."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/near-examples/crossword-tutorial-chapter-2/blob/276217ad82c64c610148e998ec926942ba910a12/contract/src/lib.rs#L81-L90\n")),(0,a.kt)("p",null,"So during the initialization function (",(0,a.kt)("inlineCode",{parentName:"p"},"new"),") we're setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"owner_id"),". For our purposes the owner will likely be the contract itself, but there can be several reasons to have it be a DAO or another user. Next, let's look at the ",(0,a.kt)("inlineCode",{parentName:"p"},'b"c"')," and ",(0,a.kt)("inlineCode",{parentName:"p"},'b"u"')," bits for the collection fields."),(0,a.kt)("h2",{id:"collections-have-prefixes"},"Collections have prefixes"),(0,a.kt)("p",null,"Above, the ",(0,a.kt)("inlineCode",{parentName:"p"},"new")," function is initializing the struct's fields by giving them a unique prefix. You can learn more about ",(0,a.kt)("a",{parentName:"p",href:"/sdk/rust/contract-structure/nesting#traditional-approach-for-unique-prefixes"},"the prefixes here"),", but know that these prefixes (",(0,a.kt)("inlineCode",{parentName:"p"},"c")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"u"),") should be short and different."),(0,a.kt)("p",null,"Let's take a peek at how we'll add a new crossword puzzle. Note that there will be a new struct here, ",(0,a.kt)("inlineCode",{parentName:"p"},"Answer"),", which we haven't defined yet. We'll also be introducing the concept of enums, like ",(0,a.kt)("inlineCode",{parentName:"p"},"PuzzleStatus::Solved")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"PuzzleStatus::Unsolved"),". We'll be covering these in the next section."),(0,a.kt)("p",null,"Unlike the previous chapter where there was only one crossword puzzle, we'll be inserting into our new collections, so let's create a ",(0,a.kt)("inlineCode",{parentName:"p"},"new_puzzle")," method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/near-examples/crossword-tutorial-chapter-2/blob/8ec941c82539e6eafa4971444e1da9e4819330d3/contract/src/lib.rs#L147-L163\n")),(0,a.kt)("p",null,"Now we're set up to store multiple puzzles!"),(0,a.kt)("h2",{id:"permissions-or-permissionless"},"Permissions or permissionless?"),(0,a.kt)("figure",null,(0,a.kt)("img",{src:s,alt:"Guards or bouncers in front of a futuristic club with the label of a NEAR smart contract. Art created by connoisseur_dane.near",width:"600"}),(0,a.kt)("figcaption",null,"Guarding which accounts can enter the smart contract logic.",(0,a.kt)("br",null),"Art by ",(0,a.kt)("a",{href:"https://twitter.com/connoisseurdane",target:"_blank"},"connoisseur_dane.near"))),(0,a.kt)("br",null),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Is NEAR permissionless?")),(0,a.kt)("p",null,"Yes. "),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What did you mean by a permission system earlier, and what are the ways you can control permissions?")),(0,a.kt)("p",null,"There are two ways that permissions can be controlled:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"In the smart contract code itself"),(0,a.kt)("li",{parentName:"ol"},"When using function-call access keys")),(0,a.kt)("p",null,"We'll get to the second topic in later in this chapter, but will focus on the first item."),(0,a.kt)("p",null,"As you can see in the previous snippet, the first thing that happens in the ",(0,a.kt)("inlineCode",{parentName:"p"},"new_puzzle")," method is a check. It looks to see if the predecessor (the person who most recently called this method, sometimes the same as the signer) is the same as the ",(0,a.kt)("inlineCode",{parentName:"p"},"owner_id")," that we set during the contract's initialization."),(0,a.kt)("p",null,"If someone else is trying to call ",(0,a.kt)("inlineCode",{parentName:"p"},"new_puzzle"),", this check will fail and the smart contract will panic, going no further. This example is the simplest form of a permission. Much more complex system can exist for users. The SputnikDAO smart contracts, for instance, implement custom policies. It's up the smart contract developer to write their roles/policies and apply them to users. Sometimes an allow-list (or whitelist) is used."),(0,a.kt)("p",null,"In short, ",(0,a.kt)("strong",{parentName:"p"},"any account with a full-access key can call any method on a smart contract"),", but that doesn't mean the smart contract will let them continue execution. It's up to the developer to protect their functions with guards like the one in ",(0,a.kt)("inlineCode",{parentName:"p"},"new_puzzle"),"."),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Let's dive into structs and enums next."))}k.isMDXComponent=!0}}]);