"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8448],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||r;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},90228:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var a=n(87462),i=n(63366),r=(n(67294),n(3905)),o=["components"],l={id:"serialization",title:"Notes on Serialization"},s=void 0,p={unversionedId:"develop/contracts/serialization",id:"develop/contracts/serialization",title:"Notes on Serialization",description:"Smart contracts need to be able to communicate complex data in a simple way, while",source:"@site/../docs/2.develop/contracts/serialization.md",sourceDirName:"2.develop/contracts",slug:"/develop/contracts/serialization",permalink:"/develop/contracts/serialization",draft:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/2.develop/contracts/serialization.md",tags:[],version:"current",lastUpdatedBy:"[sm-stack]",lastUpdatedAt:1675844989,formattedLastUpdatedAt:"Feb 8, 2023",frontMatter:{id:"serialization",title:"Notes on Serialization"},sidebar:"develop",previous:{title:"\u2705 Checklist",permalink:"/develop/contracts/security/checklist"},next:{title:"Introduction",permalink:"/develop/testing/introduction"}},u={},c=[{value:"Overview of Serialization Formats",id:"overview-of-serialization-formats",level:2},{value:"JSON: Objects to Strings",id:"json-objects-to-strings",level:3},{value:"Features",id:"features",level:4},{value:"Example",id:"example",level:4},{value:"Borsh: Objects to Bytes",id:"borsh-objects-to-bytes",level:3},{value:"Features",id:"features-1",level:4},{value:"Example",id:"example-1",level:4},{value:"Serializing Input &amp; Output",id:"serializing-input--output",level:2},{value:"Example",id:"example-2",level:4},{value:"Receiving Data",id:"receiving-data",level:4},{value:"Returning Data",id:"returning-data",level:4},{value:"Borsh: State Serialization",id:"borsh-state-serialization",level:2},{value:"Example",id:"example-3",level:4},{value:"Empty State On Deploy",id:"empty-state-on-deploy",level:4},{value:"Initializing the State",id:"initializing-the-state",level:4},{value:"Modifying the State",id:"modifying-the-state",level:4},{value:"Deserialization Error",id:"deserialization-error",level:3}],d={toc:c};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Smart contracts need to be able to ",(0,r.kt)("strong",{parentName:"p"},"communicate complex data")," in a simple way, while\nalso ",(0,r.kt)("strong",{parentName:"p"},"reading and storing")," such data into their states efficiently."),(0,r.kt)("p",null,"To achieve such simple communication and efficient storage, smart contracts morph the data\nfrom their complex representation into simpler ones."),(0,r.kt)("p",null,"This process of translating ",(0,r.kt)("strong",{parentName:"p"},"complex objects into simpler single-value")," representations is called\n",(0,r.kt)("strong",{parentName:"p"},"serialization"),". NEAR uses two serialization formats: ",(0,r.kt)("a",{parentName:"p",href:"https://www.json.org/json-en.html"},"JSON")," and\n",(0,r.kt)("a",{parentName:"p",href:"https://borsh.io/"},"Borsh"),"."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://www.json.org/json-en.html"},"JSON")," is used to serialize the contract's input/output during a method call"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://borsh.io/"},"Borsh")," is used to serialize the contract's state.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"overview-of-serialization-formats"},"Overview of Serialization Formats"),(0,r.kt)("p",null,"Lets give a quick overview of both serialization formats, including their pros and cons, as well as\nan example on how their serializations look like."),(0,r.kt)("hr",{class:"subsection"}),(0,r.kt)("h3",{id:"json-objects-to-strings"},(0,r.kt)("a",{parentName:"h3",href:"https://www.json.org/json-en.html"},"JSON"),": Objects to Strings"),(0,r.kt)("h4",{id:"features"},"Features"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Self-describing format"),(0,r.kt)("li",{parentName:"ul"},"Easy interoperability with JavaScript"),(0,r.kt)("li",{parentName:"ul"},"Multiple implementations readily available"),(0,r.kt)("li",{parentName:"ul"},"But... it is not efficient both in computational times and resulting size")),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'Example{\n  number: i32 = 2;\n  arr: Vector<i32> = [0, 1];\n}\n\n// serializes to\n"{\\"number\\": 2, \\"arr\\": [0, 1]}"\n')),(0,r.kt)("hr",{class:"subsection"}),(0,r.kt)("h3",{id:"borsh-objects-to-bytes"},(0,r.kt)("a",{parentName:"h3",href:"https://borsh.io/"},"Borsh"),": Objects to Bytes"),(0,r.kt)("h4",{id:"features-1"},"Features"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Compact, binary format built to be efficiently (de)serialized"),(0,r.kt)("li",{parentName:"ul"},"Strict and canonical binary representation"),(0,r.kt)("li",{parentName:"ul"},"Less overhead: it does not need to store attributes names"),(0,r.kt)("li",{parentName:"ul"},"But... it is necessary to know the schema to (de)serialize the data")),(0,r.kt)("h4",{id:"example-1"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"Example{\n  number: i32 = 2;\n  arr: Vector<i32> = [0, 1];\n}\n\n// serializes into\n[2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"serializing-input--output"},"Serializing Input & Output"),(0,r.kt)("p",null,"NEAR contracts can implement methods that both take and return complex objects.\nIn order to handle this data in a simple way, JSON serialization is used."),(0,r.kt)("p",null,"Using JSON makes it easier for everyone to talk with the contracts, since most\nlanguages readily implement a JSON (de)serializer."),(0,r.kt)("h4",{id:"example-2"},"Example"),(0,r.kt)("p",null,"Let's look at this example, written only for educational purposes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize)]\n#[serde(crate = "near_sdk::serde")]\npub struct A {\n  pub a_number: i32,\n  pub b_number: u128\n}\n\n#[derive(Serialize)]\n#[serde(crate = "near_sdk::serde")]\npub struct B {\n  pub success: bool,\n  pub other_number: i32\n}\n\npub fn method(&self, struct_a: A): B {\n  return B{true, 0}\n}\n')),(0,r.kt)("h4",{id:"receiving-data"},"Receiving Data"),(0,r.kt)("p",null,"When a user calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"method"),", the contract receives the arguments encoded as a JSON string\n(e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},'"{\\"a_number\\":0, \\"b_number\\":\\"100\\"}"'),"), and proceed to (de)serialize them into\nthe correct object (",(0,r.kt)("inlineCode",{parentName:"p"},"A{0, 100}"),") ."),(0,r.kt)("h4",{id:"returning-data"},"Returning Data"),(0,r.kt)("p",null,"When returning the result, the contract will automatically encode the object ",(0,r.kt)("inlineCode",{parentName:"p"},"B{true, 0}"),"\ninto its JSON serialized value: ",(0,r.kt)("inlineCode",{parentName:"p"},'"{\\"success\\":true, \\"other_number\\":0}"')," and return this\nstring."),(0,r.kt)("admonition",{title:"JSON Limitations",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Since JSON is limited to ",(0,r.kt)("inlineCode",{parentName:"p"},"52 bytes")," numbers, you cannot use ",(0,r.kt)("inlineCode",{parentName:"p"},"u64"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"u128")," as input\nor output. JSON simply cannot serialize them. Instead, you must use ",(0,r.kt)("inlineCode",{parentName:"p"},"Strings"),"."),(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"NEAR SDK RS")," currently implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"near_sdk::json_types::{U64, I64, U128, I128}"),"\nthat you can use for input / output of data.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"borsh-state-serialization"},"Borsh: State Serialization"),(0,r.kt)("p",null,"Under the hood smart contracts store data using simple ",(0,r.kt)("strong",{parentName:"p"},"key/value pairs"),". This means that\nthe contract needs to translate complex states into simple key-value pairs."),(0,r.kt)("p",null,"For this, NEAR contracts use ",(0,r.kt)("a",{parentName:"p",href:"https://borsh.io"},"borsh")," which is optimized for (de)serializing\ncomplex objects into smaller streams of bytes."),(0,r.kt)("admonition",{title:"SDK-JS still uses json",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The JavaScript SDK uses JSON to serialize objects in the state, but the borsh implementation\nshould arrive soon")),(0,r.kt)("h4",{id:"example-3"},"Example"),(0,r.kt)("p",null,"Let's look at this example, written only for educational purposes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract {\n  string: String,\n  vector: Vector<u8>\n}\n\n#[near_bindgen]\nimpl Contract {\n  #[init]\n  pub fn init(string: String, first_u8: u8) -> Self {\n    let mut vector: Vector<u8> = Vector::new("prefix".as_bytes());\n    vector.push(&first_u8);\n\n    Self { string, vector }\n  }\n\n  pub fn change_state(&mut self, string: String, number: u8) {\n    self.string = string;\n    self.vector.push(&number);\n  }\n}\n')),(0,r.kt)("h4",{id:"empty-state-on-deploy"},"Empty State On Deploy"),(0,r.kt)("p",null,"If we deploy the contract into a new account and immediately ask for the state we will see\nit is empty:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"near view-state $CONTRACT --finality optimistic\n\n# Result is: []\n")),(0,r.kt)("h4",{id:"initializing-the-state"},"Initializing the State"),(0,r.kt)("p",null,"If we initialize the state we can see how Borsh is used to serialize the state"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# initialize with the string \"hi\" and 0\nnear call $CONTRACT init '{\"string\":\"hi\", \"first_u8\":0}' --accountId $CONTRACT\n\n# check the state\nnear view-state $CONTRACT --utf8 --finality optimistic\n\n# Result is:\n# [\n#   {\n#     key: 'STATE',\n#     value: '\\x02\\x00\\x00\\x00hi\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x06\\x00\\x00\\x00prefix'\n#   },\n#   { key: 'prefix\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00', value: '\\x00' }\n# ]\n")),(0,r.kt)("p",null,"The first key-value is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"key: 'STATE'\nvalue: '\\x02\\x00\\x00\\x00hi\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x06\\x00\\x00\\x00prefix'\n")),(0,r.kt)("p",null,"Since the ",(0,r.kt)("inlineCode",{parentName:"p"},"Contract")," has a structure ",(0,r.kt)("inlineCode",{parentName:"p"},"string, Vector<u8>")," the value is interpreted as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'[2, 0, 0, 0, "h", "i"] -> The `string` has 2 elements: "h" and "i".\n[1, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, "prefix"] -> The Vector has 1 element, and to see the values search for keys that start with (the 6 bytes prefix): "prefix"\n')),(0,r.kt)("p",null,"Then, the second key-value shows the entries of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector")," denoted by the ",(0,r.kt)("inlineCode",{parentName:"p"},'"prefix"')," string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"key: 'prefix\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\nvalue: '\\x00'\n")),(0,r.kt)("h4",{id:"modifying-the-state"},"Modifying the State"),(0,r.kt)("p",null,"If we modify the stored string and add a new number, the state changes accordingly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"near call $CONTRACT change_state '{\"string\":\"bye\", \"number\":1}' --accountId $CONTRACT\n\n# Result is\n# [\n#   {\n#     key: 'STATE',\n#     value: '\\x03\\x00\\x00\\x00bye\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x06\\x00\\x00\\x00prefix'\n#   },\n#   { key: 'prefix\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00', value: '\\x00' },\n#   { key: 'prefix\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00', value: '\\x01' }\n# ]\n")),(0,r.kt)("p",null,"We can see that the ",(0,r.kt)("inlineCode",{parentName:"p"},"STATE")," key changes to reflect the storage of the new string (",(0,r.kt)("inlineCode",{parentName:"p"},"bye"),"), and that\nthe vector now has 2 elements."),(0,r.kt)("p",null,"At the same time, a new key-value was added adding the new vector entry: the ",(0,r.kt)("inlineCode",{parentName:"p"},"1u8")," we just added."),(0,r.kt)("hr",{class:"subsection"}),(0,r.kt)("h3",{id:"deserialization-error"},"Deserialization Error"),(0,r.kt)("p",null,"When somebody invokes a smart contract method, the first step for the contract is to deserialize\nits own state."),(0,r.kt)("p",null,"In the example used above, the contract will start by reading the ",(0,r.kt)("inlineCode",{parentName:"p"},"STATE")," key and\ntry to deserialize its value into an object ",(0,r.kt)("inlineCode",{parentName:"p"},"Contract{string: String, vector: Vector<u8>}"),"."),(0,r.kt)("p",null,"If you deploy a contract into the account with a different Contract structure, then the\ncontract will fail to deserialize the ",(0,r.kt)("inlineCode",{parentName:"p"},"STATE")," key and panic ",(0,r.kt)("inlineCode",{parentName:"p"},"Cannot deserialize the contract state"),"."),(0,r.kt)("p",null,"To solve this, you can either:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Rollback to the previous contract code"),(0,r.kt)("li",{parentName:"ol"},"Implement a method to ",(0,r.kt)("a",{parentName:"li",href:"/develop/upgrade"},"migrate the contract's state"))))}m.isMDXComponent=!0}}]);